{
  "type": "object",
  "properties": {
    "name": {
      "type": [
        "string",
        "null"
      ],
      "title": "Name is the name of the metric"
    },
    "phase": {
      "type": [
        "string",
        "null"
      ],
      "title": "Phase is the overall aggregate status of the metric"
    },
    "measurements": {
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "phase": {
            "type": [
              "string",
              "null"
            ],
            "title": "Phase is the status of this single measurement"
          },
          "message": {
            "type": [
              "string",
              "null"
            ],
            "title": "Message contains a message describing current condition (e.g. error messages)"
          },
          "startedAt": {
            "type": [
              "object",
              "null"
            ],
            "properties": {
              "seconds": {
                "type": [
                  "string",
                  "null"
                ],
                "format": "int64",
                "description": "Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive."
              },
              "nanos": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "int32",
                "description": "Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context."
              }
            },
            "description": "Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false"
          },
          "finishedAt": {
            "type": [
              "object",
              "null"
            ],
            "properties": {
              "seconds": {
                "type": [
                  "string",
                  "null"
                ],
                "format": "int64",
                "description": "Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive."
              },
              "nanos": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "int32",
                "description": "Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context."
              }
            },
            "description": "Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false"
          },
          "value": {
            "type": [
              "string",
              "null"
            ],
            "title": "Value is the measured value of the metric"
          },
          "metadata": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": {
              "type": [
                "string",
                "null"
              ]
            },
            "title": "Metadata stores additional metadata about this metric result, used by the different providers\n(e.g. kayenta run ID, job name)"
          },
          "resumeAt": {
            "type": [
              "object",
              "null"
            ],
            "properties": {
              "seconds": {
                "type": [
                  "string",
                  "null"
                ],
                "format": "int64",
                "description": "Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive."
              },
              "nanos": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "int32",
                "description": "Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context."
              }
            },
            "description": "Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false"
          }
        },
        "title": "Measurement is a point in time result value of a single metric, and the time it was measured"
      },
      "title": "Measurements holds the most recent measurements collected for the metric"
    },
    "message": {
      "type": [
        "string",
        "null"
      ],
      "title": "Message contains a message describing current condition (e.g. error messages)"
    },
    "count": {
      "type": [
        "integer",
        "null"
      ],
      "format": "int32",
      "title": "Count is the number of times the metric was measured without Error\nThis is equal to the sum of Successful, Failed, Inconclusive"
    },
    "successful": {
      "type": [
        "integer",
        "null"
      ],
      "format": "int32",
      "title": "Successful is the number of times the metric was measured Successful"
    },
    "failed": {
      "type": [
        "integer",
        "null"
      ],
      "format": "int32",
      "title": "Failed is the number of times the metric was measured Failed"
    },
    "inconclusive": {
      "type": [
        "integer",
        "null"
      ],
      "format": "int32",
      "title": "Inconclusive is the number of times the metric was measured Inconclusive"
    },
    "error": {
      "type": [
        "integer",
        "null"
      ],
      "format": "int32",
      "title": "Error is the number of times an error was encountered during measurement"
    },
    "consecutiveError": {
      "type": [
        "integer",
        "null"
      ],
      "format": "int32",
      "title": "ConsecutiveError is the number of times an error was encountered during measurement in succession\nResets to zero when non-errors are encountered"
    },
    "dryRun": {
      "type": [
        "boolean",
        "null"
      ],
      "title": "DryRun indicates whether this metric is running in a dry-run mode or not"
    },
    "metadata": {
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "type": [
          "string",
          "null"
        ]
      },
      "description": "Metadata stores additional metadata about this metric. It is used by different providers to store\nthe final state which gets used while taking measurements. For example, Prometheus uses this field\nto store the final resolved query after substituting the template arguments."
    },
    "consecutiveSuccess": {
      "type": [
        "integer",
        "null"
      ],
      "format": "int32",
      "title": "ConsecutiveSuccess is the number of times a measurement was successful in succession\nResets to zero when failures, inconclusive measurements, or errors are encountered"
    }
  },
  "title": "MetricResult contain a list of the most recent measurements for a single metric along with\ncounters on how often the measurement",
  "$schema": "http://json-schema.org/schema#"
}