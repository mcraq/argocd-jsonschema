type: object
properties:
  accessModes:
    type:
      - array
      - "null"
    items:
      type:
        - string
        - "null"
    title: |-
      accessModes contains the desired access modes the volume should have.
      More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
      +optional
  selector:
    type:
      - object
      - "null"
    properties:
      matchLabels:
        type:
          - object
          - "null"
        additionalProperties:
          type:
            - string
            - "null"
        title: |-
          matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
          map is equivalent to an element of matchExpressions, whose key field is "key", the
          operator is "In", and the values array contains only "value". The requirements are ANDed.
          +optional
      matchExpressions:
        type:
          - array
          - "null"
        items:
          type:
            - object
            - "null"
          properties:
            key:
              type:
                - string
                - "null"
              description: key is the label key that the selector applies to.
            operator:
              type:
                - string
                - "null"
              description: |-
                operator represents a key's relationship to a set of values.
                Valid operators are In, NotIn, Exists and DoesNotExist.
            values:
              type:
                - array
                - "null"
              items:
                type:
                  - string
                  - "null"
              title: |-
                values is an array of string values. If the operator is In or NotIn,
                the values array must be non-empty. If the operator is Exists or DoesNotExist,
                the values array must be empty. This array is replaced during a strategic
                merge patch.
                +optional
          description: |-
            A label selector requirement is a selector that contains values, a key, and an operator that
            relates the key and values.
        title: |-
          matchExpressions is a list of label selector requirements. The requirements are ANDed.
          +optional
    title: |-
      A label selector is a label query over a set of resources. The result of matchLabels and
      matchExpressions are ANDed. An empty label selector matches all objects. A null
      label selector matches no objects.
      +structType=atomic
  resources:
    type:
      - object
      - "null"
    properties:
      limits:
        type:
          - object
          - "null"
        additionalProperties:
          type:
            - object
            - "null"
          properties:
            string:
              type:
                - string
                - "null"
          description: |-
            Quantity is a fixed-point representation of a number.
            It provides convenient marshaling/unmarshaling in JSON and YAML,
            in addition to String() and AsInt64() accessors.

            The serialization format is:

            ```
            <quantity>        ::= <signedNumber><suffix>

            	(Note that <suffix> may be empty, from the "" case in <decimalSI>.)

            <digit>           ::= 0 | 1 | ... | 9
            <digits>          ::= <digit> | <digit><digits>
            <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits>
            <sign>            ::= "+" | "-"
            <signedNumber>    ::= <number> | <sign><number>
            <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI>
            <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei

            	(International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)

            <decimalSI>       ::= m | "" | k | M | G | T | P | E

            	(Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)

            <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>
            ```

            No matter which of the three exponent forms is used, no quantity may represent
            a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal
            places. Numbers larger or more precise will be capped or rounded up.
            (E.g.: 0.1m will rounded up to 1m.)
            This may be extended in the future if we require larger or smaller quantities.

            When a Quantity is parsed from a string, it will remember the type of suffix
            it had, and will use the same type again when it is serialized.

            Before serializing, Quantity will be put in "canonical form".
            This means that Exponent/suffix will be adjusted up or down (with a
            corresponding increase or decrease in Mantissa) such that:

            - No precision is lost
            - No fractional digits will be emitted
            - The exponent (or suffix) is as large as possible.

            The sign will be omitted unless the number is negative.

            Examples:

            - 1.5 will be serialized as "1500m"
            - 1.5Gi will be serialized as "1536Mi"

            Note that the quantity will NEVER be internally represented by a
            floating point number. That is the whole point of this exercise.

            Non-canonical values will still parse as long as they are well formed,
            but will be re-emitted in their canonical form. (So always use canonical
            form, or don't diff.)

            This format is intended to make it difficult to use these numbers without
            writing some sort of special handling code in the hopes that that will
            cause implementors to also use a fixed point implementation.

            +protobuf=true
            +protobuf.embed=string
            +protobuf.options.marshal=false
            +protobuf.options.(gogoproto.goproto_stringer)=false
            +k8s:deepcopy-gen=true
            +k8s:openapi-gen=true
        title: |-
          Limits describes the maximum amount of compute resources allowed.
          More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
          +optional
      requests:
        type:
          - object
          - "null"
        additionalProperties:
          type:
            - object
            - "null"
          properties:
            string:
              type:
                - string
                - "null"
          description: |-
            Quantity is a fixed-point representation of a number.
            It provides convenient marshaling/unmarshaling in JSON and YAML,
            in addition to String() and AsInt64() accessors.

            The serialization format is:

            ```
            <quantity>        ::= <signedNumber><suffix>

            	(Note that <suffix> may be empty, from the "" case in <decimalSI>.)

            <digit>           ::= 0 | 1 | ... | 9
            <digits>          ::= <digit> | <digit><digits>
            <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits>
            <sign>            ::= "+" | "-"
            <signedNumber>    ::= <number> | <sign><number>
            <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI>
            <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei

            	(International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)

            <decimalSI>       ::= m | "" | k | M | G | T | P | E

            	(Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)

            <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>
            ```

            No matter which of the three exponent forms is used, no quantity may represent
            a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal
            places. Numbers larger or more precise will be capped or rounded up.
            (E.g.: 0.1m will rounded up to 1m.)
            This may be extended in the future if we require larger or smaller quantities.

            When a Quantity is parsed from a string, it will remember the type of suffix
            it had, and will use the same type again when it is serialized.

            Before serializing, Quantity will be put in "canonical form".
            This means that Exponent/suffix will be adjusted up or down (with a
            corresponding increase or decrease in Mantissa) such that:

            - No precision is lost
            - No fractional digits will be emitted
            - The exponent (or suffix) is as large as possible.

            The sign will be omitted unless the number is negative.

            Examples:

            - 1.5 will be serialized as "1500m"
            - 1.5Gi will be serialized as "1536Mi"

            Note that the quantity will NEVER be internally represented by a
            floating point number. That is the whole point of this exercise.

            Non-canonical values will still parse as long as they are well formed,
            but will be re-emitted in their canonical form. (So always use canonical
            form, or don't diff.)

            This format is intended to make it difficult to use these numbers without
            writing some sort of special handling code in the hopes that that will
            cause implementors to also use a fixed point implementation.

            +protobuf=true
            +protobuf.embed=string
            +protobuf.options.marshal=false
            +protobuf.options.(gogoproto.goproto_stringer)=false
            +k8s:deepcopy-gen=true
            +k8s:openapi-gen=true
        title: |-
          Requests describes the minimum amount of compute resources required.
          If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
          otherwise to an implementation-defined value. Requests cannot exceed Limits.
          More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
          +optional
    description: VolumeResourceRequirements describes the storage resource requirements for a volume.
  volumeName:
    type:
      - string
      - "null"
    title: |-
      volumeName is the binding reference to the PersistentVolume backing this claim.
      +optional
  storageClassName:
    type:
      - string
      - "null"
    title: |-
      storageClassName is the name of the StorageClass required by the claim.
      More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
      +optional
  volumeMode:
    type:
      - string
      - "null"
    title: |-
      volumeMode defines what type of volume is required by the claim.
      Value of Filesystem is implied when not included in claim spec.
      +optional
  dataSource:
    type:
      - object
      - "null"
    properties:
      apiGroup:
        type:
          - string
          - "null"
        title: |-
          APIGroup is the group for the resource being referenced.
          If APIGroup is not specified, the specified Kind must be in the core API group.
          For any other third-party types, APIGroup is required.
          +optional
      kind:
        type:
          - string
          - "null"
        title: Kind is the type of resource being referenced
      name:
        type:
          - string
          - "null"
        title: Name is the name of resource being referenced
    title: |-
      TypedLocalObjectReference contains enough information to let you locate the
      typed referenced object inside the same namespace.
      +structType=atomic
  dataSourceRef:
    type:
      - object
      - "null"
    properties:
      apiGroup:
        type:
          - string
          - "null"
        title: |-
          APIGroup is the group for the resource being referenced.
          If APIGroup is not specified, the specified Kind must be in the core API group.
          For any other third-party types, APIGroup is required.
          +optional
      kind:
        type:
          - string
          - "null"
        title: Kind is the type of resource being referenced
      name:
        type:
          - string
          - "null"
        title: Name is the name of resource being referenced
      namespace:
        type:
          - string
          - "null"
        title: |-
          Namespace is the namespace of resource being referenced
          Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
          (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
          +featureGate=CrossNamespaceVolumeDataSource
          +optional
  volumeAttributesClassName:
    type:
      - string
      - "null"
    title: |-
      volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
      If specified, the CSI driver will create or update the volume with the attributes defined
      in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
      it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
      will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
      If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
      will be set by the persistentvolume controller if it exists.
      If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
      set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
      exists.
      More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
      (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
      +featureGate=VolumeAttributesClass
      +optional
title: |-
  PersistentVolumeClaimSpec describes the common attributes of storage devices
  and allows a Source for provider-specific attributes
$schema: http://json-schema.org/schema#
